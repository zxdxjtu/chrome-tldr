# 技术方案

## 1. 系统架构设计

### 1.1 整体架构
TLDR Chrome扩展采用典型的浏览器扩展三层架构：

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Popup UI      │    │  Content Script  │    │ Background.js   │
│ (用户交互界面)   │◄──►│ (页面内容处理)    │◄──►│ (后台服务处理)   │
└─────────────────┘    └──────────────────┘    └─────────────────┘
         ▲                       ▲                       ▲
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  本地存储        │    │   页面DOM操作     │    │   本地AI服务    │
│ (IndexedDB)     │    │   (页面高亮)      │    │ (API调用)       │
└─────────────────┘    └──────────────────┘    └─────────────────┘
```

### 1.2 组件详细说明

#### 1.2.1 Popup UI (弹出界面)
- 技术栈：HTML5 + CSS3 + JavaScript (ES6+)
- 功能：
  - 用户操作入口
  - 显示文章摘要和结构化信息
  - 配置管理界面（包括API密钥配置）
  - 状态显示和进度反馈

#### 1.2.2 Content Script (内容脚本)
- 技术栈：JavaScript (ES6+) + DOM API
- 功能：
  - 页面内容识别和提取
  - 可视化高亮显示
  - 用户交互处理
  - 与页面DOM的直接交互

#### 1.2.3 Background Script (后台脚本)
- 技术栈：JavaScript (ES6+) + Chrome Extension API
- 功能：
  - 协调各组件间通信
  - 调用AI服务API（通过用户配置的密钥）
  - 管理本地数据存储
  - 处理长期运行的任务

## 2. 核心模块设计

### 2.1 内容识别与提取模块

#### 2.1.1 技术选型
- 使用改进版Readability算法
- 结合自定义DOM过滤规则
- 支持多种网站结构适配

#### 2.1.2 功能实现
```javascript
class ContentExtractor {
  constructor() {
    this.filters = [
      new AdFilter(),
      new NavFilter(),
      new FooterFilter(),
      new SidebarFilter()
    ];
  }
  
  extract(url, dom) {
    // 1. 预处理DOM结构
    let cleanDom = this.preprocess(dom);
    
    // 2. 应用过滤规则
    cleanDom = this.applyFilters(cleanDom);
    
    // 3. 提取主要内容
    const content = this.extractMainContent(cleanDom);
    
    // 4. 结构化输出
    return this.structureContent(content);
  }
}
```

#### 2.1.3 数据结构
```javascript
const ExtractedContent = {
  title: "文章标题",
  author: "作者信息",
  publishDate: "发布日期",
  sections: [
    {
      type: "heading|paragraph|list|image",
      content: "具体内容",
      metadata: {}
    }
  ]
};
```

### 2.2 AI分析引擎模块

#### 2.2.1 技术选型
- 集成OpenAI格式API（支持OpenAI、Azure OpenAI、本地部署的兼容API等）
- 本地缓存机制
- 用户自定义API端点配置

#### 2.2.2 功能实现
```javascript
class AIAnalyzer {
  constructor(apiConfig) {
    this.apiConfig = apiConfig; // 包含API端点、密钥、模型等配置
    this.cache = new LocalCache();
  }
  
  async analyze(content) {
    // 1. 检查缓存
    const cacheKey = this.generateCacheKey(content);
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }
    
    // 2. 调用AI服务
    const analysis = await this.callAIService(content);
    
    // 3. 缓存结果
    this.cache.set(cacheKey, analysis);
    
    return analysis;
  }
  
  async callAIService(content) {
    const prompt = this.buildPrompt(content);
    // 调用OpenAI格式API
    return await this.callOpenAICompatAPI(prompt);
  }
  
  async callOpenAICompatAPI(prompt) {
    const response = await fetch(this.apiConfig.endpoint, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiConfig.apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: this.apiConfig.model,
        messages: [{ role: "user", content: prompt }],
        temperature: 0.7
      })
    });
    
    const data = await response.json();
    return this.parseAIResponse(data);
  }
}
```

#### 2.2.3 输出结构
```javascript
const AnalysisResult = {
  summary: "文章摘要",
  keyPoints: ["要点1", "要点2", "要点3"],
  keywords: ["关键词1", "关键词2"],
  entities: [
    { type: "person|organization|location", name: "实体名称" }
  ],
  sentiment: "positive|negative|neutral",
  structure: [
    { 
      title: "章节标题",
      importance: 0.8,
      keyPoints: ["要点1", "要点2"]
    }
  ]
};
```

### 2.3 可视化高亮模块

#### 2.3.1 技术选型
- CSS3高级选择器和动画
- SVG覆盖层技术
- MutationObserver监听DOM变化

#### 2.3.2 功能实现
```javascript
class Highlighter {
  constructor() {
    this.highlightStyles = {
      keyPoint: { backgroundColor: '#e3f2fd', borderLeft: '3px solid #2196f3' },
      dataPoint: { backgroundColor: '#e8f5e9', borderLeft: '3px solid #4caf50' },
      quote: { backgroundColor: '#f3e5f5', borderLeft: '3px solid #9c27b0' },
      actionItem: { backgroundColor: '#fff3e0', borderLeft: '3px solid #ff9800' }
    };
  }
  
  highlight(element, type, metadata) {
    // 添加高亮样式
    Object.assign(element.style, this.highlightStyles[type]);
    
    // 添加交互功能
    element.addEventListener('mouseenter', () => this.showTooltip(element, metadata));
    element.addEventListener('click', () => this.showDetailPanel(element, metadata));
  }
  
  createFloatingPanel(analysis) {
    const panel = document.createElement('div');
    panel.className = 'tldr-floating-panel';
    panel.innerHTML = `
      <div class="panel-header">
        <h3>TLDR 摘要</h3>
        <button class="close-btn">&times;</button>
      </div>
      <div class="panel-content">
        <div class="summary">${analysis.summary}</div>
        <div class="key-points">
          <h4>关键要点</h4>
          <ul>
            ${analysis.keyPoints.map(point => `<li>${point}</li>`).join('')}
          </ul>
        </div>
      </div>
    `;
    return panel;
  }
}
```

## 3. 技术选型

### 3.1 前端技术栈
- **核心语言**：JavaScript (ES6+)
- **构建工具**：Webpack 5
- **包管理**：npm 或 yarn
- **代码规范**：ESLint + Prettier
- **单元测试**：Jest + Puppeteer

### 3.2 AI服务集成
- **API格式**：OpenAI兼容API格式
- **支持的提供商**：
  - OpenAI官方API
  - Azure OpenAI服务
  - 本地部署的兼容服务（如LocalAI、LM Studio等）
  - 其他遵循OpenAI API格式的第三方服务

### 3.3 开发工具
- **IDE**：Visual Studio Code
- **版本控制**：Git + GitHub
- **CI/CD**：GitHub Actions
- **项目管理**：GitHub Projects

## 4. 数据存储设计

### 4.1 本地存储
使用Chrome Extension Storage API和IndexedDB：

```javascript
class LocalStorage {
  constructor() {
    this.storage = chrome.storage.local;
    this.db = null;
  }
  
  async initDB() {
    // 初始化IndexedDB用于存储分析结果
    this.db = await this.openDB('tldr', 1, upgradeDB => {
      if (!upgradeDB.objectStoreNames.contains('analyses')) {
        const store = upgradeDB.createObjectStore('analyses', { keyPath: 'id' });
        store.createIndex('url', 'url', { unique: true });
        store.createIndex('timestamp', 'timestamp');
      }
    });
  }
  
  async saveAnalysis(url, analysis) {
    const record = {
      id: this.generateId(url),
      url: url,
      analysis: analysis,
      timestamp: Date.now()
    };
    
    // 保存到Chrome Storage
    await this.storage.set({ [record.id]: record });
    
    // 同时保存到IndexedDB
    if (this.db) {
      const tx = this.db.transaction('analyses', 'readwrite');
      await tx.objectStore('analyses').put(record);
    }
  }
  
  async saveUserConfig(config) {
    // 保存用户配置（包括API密钥等）
    await this.storage.set({ userConfig: config });
  }
  
  async getUserConfig() {
    // 获取用户配置
    const result = await this.storage.get(['userConfig']);
    return result.userConfig || {};
  }
}
```

## 5. 安全与隐私设计

### 5.1 数据处理原则
- **最小数据收集**：只处理当前页面内容，不收集浏览历史
- **本地优先**：所有处理均在本地进行，数据不出用户设备
- **用户控制**：用户完全控制API密钥和数据

### 5.2 安全实现
```javascript
class PrivacyManager {
  constructor() {
    this.storage = new LocalStorage();
  }
  
  // 所有内容处理在本地进行，不发送原始内容到第三方服务器（除非用户配置的AI服务）
  async processContent(content) {
    // 仅在用户配置了AI服务时才发送内容进行分析
    const userConfig = await this.storage.getUserConfig();
    if (!userConfig.apiKey) {
      // 没有配置API密钥时，仅进行本地处理
      return this.localProcess(content);
    }
    
    // 检查是否有缓存结果
    const cached = await this.checkCache(content);
    if (cached) return cached;
    
    // 调用用户配置的AI服务
    return await this.analyzeWithAI(content, userConfig);
  }
  
  async localProcess(content) {
    // 仅本地处理，如基础关键词提取、结构识别等
    return {
      summary: "本地处理结果（需配置AI服务获取完整分析）",
      keyPoints: ["内容已提取", "需配置AI服务获取深入分析"],
      keywords: []
    };
  }
}
```

## 6. 性能优化策略

### 6.1 内容提取优化
- 使用Web Workers处理复杂计算，避免阻塞UI线程
- 实现增量处理，优先处理可见区域内容
- 缓存页面结构分析结果

### 6.2 AI分析优化
- 实现智能缓存，相同内容不重复分析
- 支持分析任务队列，避免API过载
- 提供分析进度反馈

### 6.3 高亮渲染优化
- 使用DocumentFragment批量操作DOM
- 实现虚拟滚动，处理长文档
- 使用CSS containment属性优化重绘

## 7. 开发计划

### 7.1 第一阶段：MVP开发（1-4周）
#### 第1周：基础架构搭建
- 项目初始化和开发环境配置
- Chrome扩展基础结构搭建
- 内容提取模块开发

#### 第2周：核心功能实现
- 本地处理功能实现
- 基础高亮系统实现
- Popup界面开发

#### 第3周：AI集成与配置
- OpenAI格式API集成
- 用户配置管理界面
- 本地存储实现

#### 第4周：测试与优化
- 单元测试编写
- 性能测试和优化
- 用户体验优化

### 7.2 第二阶段：功能完善（5-8周）
#### 第5周：高级高亮功能
- 多种高亮类型实现
- 交互式浮动面板
- 自定义高亮规则

#### 第6周：多格式API支持
- 支持Azure OpenAI等不同提供商
- API配置验证
- 错误处理优化

#### 第7周：性能优化
- 缓存机制优化
- 大文档处理优化
- 内存使用优化

#### 第8周：兼容性测试
- 多网站兼容性测试
- 多浏览器测试
- 边缘情况处理

### 7.3 第三阶段：扩展功能（9-12周）
#### 第9周：高级配置功能
- 多种AI模型支持
- 高级参数配置
- 配置导入导出

#### 第10周：用户体验优化
- 快捷键支持
- 更丰富的交互方式
- 界面个性化设置

#### 第11周：导出功能
- PDF导出支持
- Markdown导出
- 结果分享功能

#### 第12周：发布准备
- 文档完善
- 市场推广材料准备
- Chrome Web Store发布

## 8. 测试策略

### 8.1 单元测试
- 使用Jest进行逻辑测试
- 使用Puppeteer进行DOM操作测试
- 覆盖率目标：85%以上

### 8.2 集成测试
- Chrome扩展API模拟测试
- AI服务集成测试（使用模拟API）
- 数据存储集成测试

### 8.3 用户验收测试
- 邀请目标用户进行Beta测试
- 收集反馈并迭代优化
- 性能基准测试

## 9. 部署与维护

### 9.1 发布流程
1. 代码审查和测试
2. 版本打包和签名
3. Chrome Web Store提交
4. 发布公告和文档更新

### 9.2 监控与日志
- 本地错误日志收集
- 性能指标监控
- 用户反馈收集

### 9.3 版本管理
- 遵循语义化版本控制
- 定期发布功能更新
- 及时修复安全漏洞

## 10. 风险与应对

### 10.1 技术风险
- **API兼容性**：支持多种OpenAI兼容格式，提供配置指导
- **浏览器兼容性**：建立自动化测试矩阵
- **性能问题**：持续性能监控和优化

### 10.2 用户风险
- **密钥安全**：提供密钥管理最佳实践指导
- **成本控制**：提供API使用量预估和提醒功能
- **服务可用性**：降级到本地处理模式

### 10.3 业务风险
- **用户增长瓶颈**：持续用户反馈收集和功能迭代
- **竞争压力**：保持技术领先和用户体验优势
- **法规变化**：关注隐私法规变化，及时调整方案